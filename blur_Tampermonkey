// ==UserScript==
// @name         Blur sensitive numbers (robust)
// @match        *://*/*
// @run-at       document-end
// ==/UserScript==

(function () {
  const regex = /\b\d{4}[\u00A0\s-]\d{8}\b/g;

  const style = document.createElement("style");
  style.textContent = `
    .tm-blur-sensitive {
      filter: blur(6px);
      cursor: pointer;
    }
    .tm-blur-sensitive:hover {
      filter: none;
    }
  `;
  document.head.appendChild(style);

  function processElement(el) {
    const walker = document.createTreeWalker(
      el,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode(node) {
          if (!node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
          if (
            node.parentNode &&
            node.parentNode.classList &&
            node.parentNode.classList.contains("tm-blur-sensitive")
          ) {
            return NodeFilter.FILTER_REJECT;
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      }
    );

    const textNodes = [];
    let node;
    while ((node = walker.nextNode())) {
      textNodes.push(node);
    }

    for (let i = 0; i < textNodes.length - 1; i++) {
      const combined =
        textNodes[i].nodeValue + textNodes[i + 1].nodeValue;

      if (!regex.test(combined)) continue;

      const span = document.createElement("span");
      span.className = "tm-blur-sensitive";
      span.textContent = combined;

      textNodes[i].parentNode.insertBefore(span, textNodes[i]);
      textNodes[i].remove();
      textNodes[i + 1].remove();
    }
  }

  processElement(document.body);

  const observer = new MutationObserver(mutations => {
    for (const m of mutations) {
      m.addedNodes.forEach(node => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          processElement(node);
        }
      });
    }
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
})();
